(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{394:function(t,e,a){"use strict";a.r(e);var v=a(54),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"第二章-vue相关记录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二章-vue相关记录"}},[t._v("#")]),t._v(" 第二章 VUE相关记录")]),t._v(" "),a("h2",{attrs:{id:"_2-1-vue小知识点总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-vue小知识点总结"}},[t._v("#")]),t._v(" 2.1 vue小知识点总结")]),t._v(" "),a("h3",{attrs:{id:"_2-1-1-vue常见的组件间传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-vue常见的组件间传值"}},[t._v("#")]),t._v(" 2.1.1 vue常见的组件间传值：")]),t._v(" "),a("p",[t._v("(1) 子组件$emit抛出,父组件响应")]),t._v(" "),a("p",[t._v("(2) 父组件xx.sync=xx也是双向绑定，子组件$emit('updated:xx')抛出")]),t._v(" "),a("p",[t._v("(3) 重新创建一个实例实现eventBus事件总线，原理为在新的实例上通过$on, $emit传递和响应")]),t._v(" "),a("p",[t._v("(4) 通过provide,inject传递函数和参数")]),t._v(" "),a("p",[t._v("(5) 通过ref来获取组件实例，ref不能在template上使用，compute也不能用")]),t._v(" "),a("p",[t._v("补充：this.$parent可以拿到父组件一系列属性")]),t._v(" "),a("h3",{attrs:{id:"_2-1-2-nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-nexttick"}},[t._v("#")]),t._v(" 2.1.2 $nextTick")]),t._v(" "),a("p",[t._v("(1) Vue是异步渲染")]),t._v(" "),a("p",[t._v("(2) data改变后，DOM不会立刻渲染（异步去渲染）")]),t._v(" "),a("p",[t._v("(3) $nextTick会在DOM渲染之后被触发，以获取最新的DOM节点")]),t._v(" "),a("p",[t._v("this.$nextTick( callback ) callback是等DOM渲染完再回调的")]),t._v(" "),a("p",[t._v("(4) 页面渲染时会将data的修改做整合，多次data修改只会渲染一次")])])}),[],!1,null,null,null);e.default=_.exports}}]);