# 第2章 VUE相关记录 

## 2.1 vue组件通信常用方式

(1) **props** 
```vue
<!--parent-->
<Child msg='gogogo'/>

<!--child,父给子传值-->
props: {msg: String}
```
**自定义事件**  
```vue
<!--child-->
this.$emit('add', data)
<!--parent, 子给父传值-->
<Child @add="handleAdd($event)"/>
```

(2) **.sync**

父组件xx.sync=xx也是双向绑定，子组件$emit('updated:xx')抛出

(3) **eventBus**

重新创建一个实例实现eventBus事件总线，原理为在新的实例上通过$on, $emit传递和响应

```js
//bus.js
//事件总线  任意两个组件之间传值常用事件总线或vuex
//手写一个eventBus 事件派发，监听
class eventBus {
  cache = {}
// {
//   'name1': [fn1, fn2, fn3],
//   'name2': [fn1, fn2, fn3]
// }
  $on(name, fn) {
    //把fn推进this.cache[name]数组
    this.cache[name] = this.cache[name] || []
    this.cache[name].push(fn)
  }
  $emit(name, data) {
    //把数组里的fn全部依次调用
    (this.cache[name] || []).forEach(fn => fn(data))
  }
}

export default eventBus

//在main.js中
//Vue.prototype.$bus = new Bus()
```

(4) **provide/inject**

通过provide,inject传递函数和参数。可以实现祖先和后代之间传值

```vue
<!--ancestor-->
provide() {
  return {foo: 'datas'}
}
<!--descendant-->
inject: ['foo']
```

(5) **ref**

通过ref来获取组件实例，ref不能在template上使用
```vue
<!--parent-->
<Child ref="card"/>

mounted: {
  this.$refs.card.xxx = 'xxxx'
}
```

(6) **$parent/$root**

this.$parent可以拿到父组件一系列属性。兄弟组件之间通信可以通过共同祖辈搭桥。父组件也可通过$children访问子组件，不保证子元素顺序
```vue
<!--child1-->
this.$parent.$on('foo', do)
<!--child2-->
this.$parent.$emit('foo')
<!--parent-->
this.$children[0].xxx = 'xxxxx'
```

(7)**$attrs/$listeners**

爷孙组件间通信

## 2.2 其他vue相关

### 2.2.1 $nextTick

(1) Vue是异步渲染

(2) data改变后，DOM不会立刻渲染（异步去渲染）

(3) $nextTick会在DOM渲染之后被触发，以获取最新的DOM节点

this.$nextTick( callback ) callback是等DOM渲染完再回调的

(4) 页面渲染时会将data的修改做整合，多次data修改只会渲染一次


### 2.2.2 vue.config.js中的publicPath

配置静态文件的（相对或绝对）路径，'/'的意思就是静态资源是在根路径底下。示例代码：
```js
module.exports = {
  publicPath: process.env.NODE_ENV === 'production' ? '/dist/' : '/'
}
```
